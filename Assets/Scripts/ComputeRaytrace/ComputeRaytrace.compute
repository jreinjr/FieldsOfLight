// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel FindIntersection
#define INF 1.0e38

float3 camPos;
float3 camFwd;
float3 camRgt;
float3 camUp;

/// Top Left corner:     row=0
/// Top Right corner:    row=1
/// Bottom Right corner: row=2
/// Bottom Left corner:  row=3
float4x4 camCorners;

float2 resolution;

bool frustum(float3 org, float3 dir, float apex, out float near, out float far);

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

[numthreads(8,8,1)]
void FindIntersection(uint3 id : SV_DispatchThreadID)
{

	// camera
	float2 uv = id.xy / resolution.xy;
	float3 camro = camPos;
	float4 fragColor = float4(0.0, 0.0, 0.0, 0.0);

	float3 ray = lerp(lerp(camCorners[0], camCorners[1], uv.x), lerp(camCorners[2], camCorners[3], uv.x), uv.y);

	float far;
	float near;

	if (frustum(camro, ray, -0.5, near, far)) {
		fragColor = float4(camro + ray * near, 1);
	}

	Result[id.xy] = float4(fragColor);
}


bool frustum(float3 org, float3 dir, float apex, out float near, out float far) {
	float2 dirf = float2(0.5 - apex, 0.5);
	float3 tbot, ttop;

	// intersection with near and far planes
	float invdirz = 1.0 / dir.z;
	tbot.z = invdirz * (.2 - org.z);
	ttop.z = invdirz * (1.5 - org.z);

	float temp = dirf.y * (org.z - apex);

	// intersection with inclined planes on y
	tbot.y = (-temp - dirf.x * org.y) / (dirf.x * dir.y + dirf.y * dir.z);
	ttop.y = (temp - dirf.x * org.y) / (dirf.x * dir.y - dirf.y * dir.z);

	// intersection with inclined planes on x
	tbot.x = (-temp - dirf.x * org.x) / (dirf.x * dir.x + dirf.y * dir.z);
	ttop.x = (temp - dirf.x * org.x) / (dirf.x * dir.x - dirf.y * dir.z);

	// if intersecting behind the apex, set t to ray's end
	float4 tempt = float4(tbot.xy, ttop.xy);
	tempt = lerp(tempt, INF * sign(dir.zzzz), step(org.zzzz + tempt * dir.zzzz, apex.xxxx));
	tbot.xy = tempt.xy;
	ttop.xy = tempt.zw;

	// re-order intersections to find smallest and largest on each axis
	float3 tmin = min(ttop, tbot);
	float3 tmax = max(ttop, tbot);

	// find the largest tmin and the smallest tmax
	float2 t0 = max(tmin.zz, tmin.xy);
	near = max(t0.x, t0.y);
	t0 = min(tmax.zz, tmax.xy);
	far = min(t0.x, t0.y);

	// check for hit
	return near < far && far > 0.0;
}

