using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;

[RequireComponent(typeof(Camera))]
public class ComputeBlend : MonoBehaviour {

    public Renderer debugEyeRenderer;

    private const int debugNumEyes = 8;

    private Camera cam;


    private void Start()
    {       
        cam = GetComponent<Camera>();
        
        InitRenderTextures();
        InitStencilMaterials();
        InitComputeBuffers();
        InitComputeShaders();
        InitCommandBuffers();

        // StencilMat will use blendtex for main texture, Eyes use as blend texture
        // This needs to be reorganized.
        debugEyeRenderer.sharedMaterial.SetTexture("_BlendTex", blendTex);
    }

    /////////////////////////////////////
    // Render Texture Setup
    /////////////////////////////////////
    private RenderTexture hitTex;
    private RenderTexture blendTex;
    private Vector2Int hitTexRes = new Vector2Int(64, 64);
    private Vector2Int blendTexRes = new Vector2Int(64, 64);
    /// <summary>
    /// Declares array textures hitTex and blendTex.
    /// hitTex stores raytrace hit positions for each Eye.
    /// blendTex stores stencil and blend weights.
    /// </summary>
    void InitRenderTextures()
    {
        // hitTex is generated by a vert+frag shader running on each frustum
        hitTex = new RenderTexture(hitTexRes.x, hitTexRes.y, 0, RenderTextureFormat.ARGBFloat);
        hitTex.dimension = TextureDimension.Tex2DArray;
        hitTex.volumeDepth = debugNumEyes;
        hitTex.filterMode = FilterMode.Point;
        hitTex.name = "HitTex";
        hitTex.Create();
        // blendTex will be generated by compute shader using one hitTex per Eye
        blendTex = new RenderTexture(blendTexRes.x, blendTexRes.y, 0, RenderTextureFormat.ARGBFloat);
        blendTex.dimension = TextureDimension.Tex2DArray;
        blendTex.volumeDepth = debugNumEyes;
        blendTex.name = "BlendTex";
        blendTex.enableRandomWrite = true;
        blendTex.Create();
    }

    /////////////////////////////////////
    // Material Setup
    /////////////////////////////////////
    private Material stencilClearMat;
    private Material writeToStencilMat;
    /// <summary>
    /// Declares materials that wipe stencil buffer to 0 or write to it based on greyscale texture value.
    /// </summary>
    void InitStencilMaterials()
    {
        // Declare materials
        stencilClearMat = new Material(Shader.Find("Unlit/ClearStencil"));
        writeToStencilMat = new Material(Shader.Find("Unlit/WriteToStencil"));
        writeToStencilMat.SetTexture("_MainTex", blendTex);
    }

    /////////////////////////////////////
    // Compute Buffer Setup
    /////////////////////////////////////
    private ComputeBuffer eyePosBuffer;
    /// <summary>
    /// Declares a compute buffer to pass Eye world space positions to our compute blend shader.
    /// </summary>
    void InitComputeBuffers()
    {
        Vector3[] eyePosArray = new Vector3[debugNumEyes];
        for (int i = 0; i < eyePosArray.Length; i++)
        {
            Debug.Log(debugEyeRenderer.gameObject.transform.position);
            eyePosArray[i] = debugEyeRenderer.gameObject.transform.position;
        }
        eyePosBuffer = new ComputeBuffer(debugNumEyes, sizeof(float) * 3, ComputeBufferType.Default);
        eyePosBuffer.SetData(eyePosArray);
    }

    /////////////////////////////////////
    // Compute Shader Setup
    /////////////////////////////////////
    public ComputeShader computeShader;
    int BlendKernel;
    /// <summary>
    /// Given WS raytrace hits and camera centers for each Eye, outputs
    /// blend weights and stencil (where blend == 0).
    /// </summary>
    void InitComputeShaders()
    {
        // Set up Compute Shader
        BlendKernel = computeShader.FindKernel("Blend");
        computeShader.SetTexture(BlendKernel, "hitTex", hitTex);
        computeShader.SetTexture(BlendKernel, "blendTex", blendTex);
        computeShader.SetBuffer(BlendKernel, "eyePosBuffer", eyePosBuffer);
        computeShader.SetInt("_EyeCount", debugNumEyes);
    }

    /////////////////////////////////////
    // Command Buffer Setup
    /////////////////////////////////////
    private CommandBuffer cmdBufferBeforeOpaque;
    private CommandBuffer cmdBufferAfterEverything;
    /// <summary>
    /// Each Eye is raytraced and hits are stored in a low res array texture.
    /// Compute Buffer is executed to compute stencil and blend weights.
    /// Eyes are raytraced and blended again only where weight > 0.
    /// </summary>
    void InitCommandBuffers()
    {
        /////////////////////////////////////
        // Command Buffer: Before Opaque
        /////////////////////////////////////
        cmdBufferBeforeOpaque = new CommandBuffer();
        cmdBufferBeforeOpaque.name = "BeforeOpaque";
        for (int i = 0; i < debugNumEyes; i++)
        {
            // Draw hit pass (pass 0) to hitTex
            cmdBufferBeforeOpaque.SetRenderTarget(hitTex, 0, CubemapFace.Unknown, i);
            cmdBufferBeforeOpaque.ClearRenderTarget(true, true, Color.clear);
            cmdBufferBeforeOpaque.DrawRenderer(debugEyeRenderer, debugEyeRenderer.sharedMaterial, 0, 0);
        }
        // Dispatch compute shader to compute blendTex from hitTex
        cmdBufferBeforeOpaque.DispatchCompute(computeShader, BlendKernel, blendTexRes.x, blendTexRes.y, 1);
        cam.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, cmdBufferBeforeOpaque);

        /////////////////////////////////////
        // Command Buffer: After Everything
        /////////////////////////////////////
        cmdBufferAfterEverything = new CommandBuffer();
        cmdBufferAfterEverything.name = "AfterEverything";
        for (int i = 0; i < debugNumEyes; i++)
        {
            cmdBufferAfterEverything.Blit(BuiltinRenderTextureType.CurrentActive, BuiltinRenderTextureType.CurrentActive, stencilClearMat);
            if (i < 4)
            {
                // Blit stencilMat to screen for each Eye
                cmdBufferAfterEverything.Blit(BuiltinRenderTextureType.CurrentActive, BuiltinRenderTextureType.CurrentActive, writeToStencilMat);
            }
            // Draw Eye (pass 1)
            cmdBufferAfterEverything.DrawRenderer(debugEyeRenderer, debugEyeRenderer.sharedMaterial, 0, 1);
        }
        cam.AddCommandBuffer(CameraEvent.AfterEverything, cmdBufferAfterEverything);
    }

    /////////////////////////////////////
    // Cleanup
    /////////////////////////////////////
    private void OnDisable()
    {
        cam.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, cmdBufferBeforeOpaque);
        cam.RemoveCommandBuffer(CameraEvent.AfterEverything, cmdBufferAfterEverything);
        hitTex.Release();
        blendTex.Release();
    }
}
