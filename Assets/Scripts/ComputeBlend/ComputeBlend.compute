// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Blend
#define NUM_EYES 8

Texture2DArray<float4> hitTex;
RWTexture2DArray<float4> blendTex;
uniform StructuredBuffer<float3> eyePosBuffer;
uniform uint _EyeCount;


float3 _camPos;

groupshared float weights[NUM_EYES];
groupshared uint sorted_keys[NUM_EYES];
[numthreads(1, 1, NUM_EYES)]
void Blend(uint3 id : SV_DispatchThreadID, uint index : SV_GroupIndex) 
{
	//if (id.z >= _EyeCount) return;
	//if (hitTex[id.xyz].w == 0) {
	//	blendTex[id.xyz] = float4(0, 0, 0, 0);
	//	return;
	//}
	const uint blend_N_eyes = 3;
	weights[index] = 0.0;
	sorted_keys[index] = 0;

	float4 hit_WS = hitTex[id.xyz];
	float3 eye_ray_WS = normalize(hit_WS.xyz - eyePosBuffer[index]);
	float3 cam_ray_WS = normalize(hit_WS.xyz - _camPos);
	float angDiff = (dot(eye_ray_WS, cam_ray_WS) + 1) / 2 * hit_WS.w;
	weights[index] = angDiff;
	uint nthLargest = 0;
	GroupMemoryBarrierWithGroupSync();
	for (uint i = 1; i < NUM_EYES; i++)
	{
		// BAD WHEN THERE ARE DUPLICATES IN LIST (UNLIKELY)
		nthLargest += weights[(index + i) % NUM_EYES] > angDiff ? 1 : 0;
	}
	float original;
	InterlockedExchange(sorted_keys[nthLargest], index, original);
	GroupMemoryBarrierWithGroupSync();
	float thresh = weights[sorted_keys[blend_N_eyes - 1]];

	float angBlend = max(0, 1 - (1-angDiff) / (1-thresh));
	//weights[index] = angBlend;
	GroupMemoryBarrierWithGroupSync();

	float angBlendSum = 0;
	for (uint j = 0; j < blend_N_eyes; j++)
	{
		angBlendSum += weights[sorted_keys[j]];
	}

	float normalizedAngBlend = angBlend / angBlendSum;

	// r (< 0.001f) is stencil, g is blend factor
	//blendTex[id.xyz] = float4(index == 0?1 * hitTex[id.xyz].w :0 , 1, 0, 0);
	/////////////////////////////////
	// Should be normalizedAngBlend but that is fucking slow - something isnt working
	/////////////////////////////////
	blendTex[id.xyz] = float4(angBlend, angBlend,0, 1);
}
